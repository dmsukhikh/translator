#pragma once
#include "Definitions.hpp"
#include "Scanner.hpp"
#include <stack>
#include <utility>
#include <unordered_map>
#include <array>

/**
 * Класс парсера, разбирающего выражение языка
 *
 * LR(0) - анализатор
 */
class Parser
{
public:
    /**
     * Конструктор
     *
     * Конфигурируем парсер подходящим конструктором
     */
    Parser(Scanner s = Scanner());

    /**
     * Разобрать выражение, поступающее на вход программе
     *
     * \return Корень дерева разбора
     * \throw SyntaxError В случае встречи некорректной синтаксической
     * конструкции
     */
    std::unique_ptr<ParseNode> parse();

    /**
     * Тип состояния из таблиц Goto и Action
     *
     * Тип значений - int8_t. Знак определяет действие: положительное число -
     * действие вида "Shift", отрицательное число - действие вида "Reduce".
     * Модуль - число, определяющее конкретную операцию LR-анализа. Число
     * учитывается только в таблице Action.
     */
    using State = int8_t;

private:
    /**
     * Массив, определяющий продукции грамматики
     *
     * Для свертки необходимо знать нетерминал, порождающийся сверткой, и
     * количество элементов, которое нужно убрать со стека. Эта информация
     * кодируется в данном массиве. Таблица соответствует нумерации из файла
     * trans.md, смотрите прямо под таблицу GOTO.
     */
    static std::array<std::pair<NonTerm, State>, 15> _products;

    /**
     * Таблица Action
     *
     * Представление таблицы Action из LR-разбора. Для оптимизационных целей
     * является двумерным массивом std::array.
     */
    static std::array<std::array<State, getEnumSize<TokenType>()>, 33>
        _action;
    

    /**
     * Массив, соответствующая таблице Goto грамматики
     */
    static std::array<std::array<State, getEnumSize<NonTerm>()>, 27> _goto;

    /**
     * Стек LR(0)-анализатора
     *
     * LR-разбор предполагает наличие стека, хранящего состояния разбора. В
     * парах, хранимых в стеке, следующие поля:
     * - first - номер состояния
     * - second - ParseNode, соответствующая состоянию разбора. Если текущее
     * состояние получено при переносе, то ParseNode хранит токен, который
     * перенесли из потока. Если состояние получено при редукции, то нода
     * означает нетерминал, хранящий в childs те ноды, которые были свернуты при
     * редукции. Таким образом, накопительно строится дерево разбора
     *
     * \note Порядок следования нод в childs такой же, как и в продукции, по
     * которой происходит сворачивание.
     */
    std::stack<std::pair<State, std::unique_ptr<ParseNode>>> _stack;

private:
    Scanner _scanner;
};
