#pragma once
#include "Definitions.hpp"
#include "Scanner.hpp"
#include <stack>
#include <utility>
#include <unordered_map>
#include <array>

/**
 * Класс парсера, разбирающего выражение языка
 *
 * LR(0) - анализатор
 */
class Parser
{
    using State = uint16_t;

    /**
     * Стек LR(0)-анализатора
     *
     * LR-разбор предполагает наличие стека, хранящего состояния разбора. В
     * парах, хранимых в стеке, следующие поля:
     * - first - номер состояния
     * - second - ParseNode, соответствующая состоянию разбора. Если текущее
     * состояние получено при переносе, то ParseNode хранит токен, который
     * перенесли из потока. Если состояние получено при редукции, то нода
     * означает нетерминал, хранящий в childs те ноды, которые были свернуты при
     * редукции. Таким образом, накопительно строится дерево разбора
     *
     * \note Порядок следования нод в childs такой же, как и в продукции, по
     * которой происходит сворачивание.
     */
    std::stack<std::pair<State, ParseNode>> _stack;

public:
    /**
     * Конструктор
     *
     * Конфигурируем парсер подходящим конструктором
     */
    Parser(Scanner s = Scanner());

    /**
     * Разобрать выражение, поступающее на вход программе
     *
     * \return Корень дерева разбора
     * \throw SyntaxError В случае встречи некорректной синтаксической
     * конструкции
     */
    ParseNode parse();

private:
    Scanner _scanner;
};
